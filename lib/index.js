#!/usr/bin/env node

const argv = process.argv.splice(2);
const fs = require("fs-extra");
const path = require("path");
const cwd = process.cwd();
const parser = require("./parser");
const YAML = require("js-yaml");
const { firstUpperCase, capUpperCase } = require("./utils");
global.fetch = require("node-fetch");

const yamlFile = argv[0] || "apiex.yaml";
const lang = argv[1];

const tempaltes = {
  dart: 1,
  go: 1,
  ts: 1,
};

if (yamlFile === "init") {
  if (!tempaltes[lang]) {
    console.error("Please input template:");
    console.error("- apiex init go");
    console.error("- apiex init ts");
    console.error("- apiex init dart");
    return;
  }
  fs.copySync(
    path.resolve(__dirname, `../apiex/apiex-${lang}.yaml`),
    path.resolve(cwd, "apiex.yaml")
  );

  fs.copySync(
    path.resolve(__dirname, `../apiex/apiex-schema.gql`),
    path.resolve(cwd, "apiex-schema.gql")
  );

  fs.copySync(
    path.resolve(__dirname, `../apiex/template/apiex-${lang}.js`),
    path.resolve(cwd, `apiex-${lang}.js`)
  );

  console.log("apiex inited!");
  return;
}

const config = YAML.load(fs.readFileSync(path.resolve(cwd, yamlFile)));

async function Start() {
  let schemaCode = "";
  for (const p of config.graphql) {
    if (/http/.test(p)) {
      const code = await fetch(p).then((v) => v.text());
      schemaCode += code;
    } else {
      schemaCode += fs.readFileSync(path.resolve(cwd, p), "utf8");
    }
  }

  delete config.graphql;

  Object.keys(config).forEach((key) => {
    const conf = config[key];
    const {
      buildCombine,
      buildInterface,
      buildType,
      buildApi,
      matchTypes,
    } = require(path.resolve(cwd, conf.builder));

    const schema = parser(schemaCode, matchTypes);

    const structs = [];
    const handles = [];
    const apis = [];

    schema.forEach((item) => {
      if (item.kind == "interface") {
        if (buildInterface) {
          handles.push(
            buildInterface({
              ...item,
              firstUpperCase,
              capUpperCase,
            })
          );
        }
        if (buildApi) {
          apis.push(
            buildApi({
              ...item,
              firstUpperCase,
              capUpperCase,
            })
          );
        }
      } else {
        if (buildType) {
          structs.push(
            buildType({
              ...item,
              firstUpperCase,
              capUpperCase,
            })
          );
        }
      }
    });

    let file = buildCombine({
      structs: structs.join("\n"),
      handles: handles.join("\n"),
      apis,
      schema: schemaCode,
    });

    const outPath = path.resolve(cwd, conf.out);
    const dir = path.parse(outPath).dir;
    if (!fs.existsSync(dir)) {
      fs.mkdirpSync(dir);
    }
    file = "// Code generated by linkgen. DO NOT EDIT." + file;
    fs.writeFileSync(outPath, file);
    console.log("Create done:", conf.out);
  });
}

Start();
