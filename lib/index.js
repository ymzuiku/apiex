#!/usr/bin/env node

const argv = process.argv.splice(2);
const fs = require("fs-extra");
const path = require("path");
const cwd = process.cwd();
const parser = require("./parser");
const YAML = require("js-yaml");
const { firstUpperCase, capUpperCase } = require("./utils");
global.fetch = require("node-fetch");

if (!argv[0] && !fs.existsSync(path.resolve(cwd, "apiex.yaml"))) {
  console.log("Ignore apiex.yaml, please run once:");
  console.error("$ apiex init go");
  console.error("$ apiex init ts");
  console.error("$ apiex init dart");
  return;
}

const yamlFile = argv[0] || "apiex.yaml";
const isFocus = argv.indexOf("-f") > -1;
const lang = argv[1];

const tempaltes = {
  dart: 1,
  go: 1,
  ts: 1,
};

const cpFile = (by, to) => {
  console.log(isFocus, "aaaa");
  if (fs.existsSync(to)) {
    if (isFocus) {
      fs.copyFileSync(by, to);
    }
  } else {
    fs.copyFileSync(by, to);
  }
};

if (yamlFile === "init") {
  if (!tempaltes[lang]) {
    console.error("Ignore template language, Please run once:");
    console.error("$ apiex init go");
    console.error("$ apiex init ts");
    console.error("$ apiex init dart");
    return;
  }

  cpFile(
    path.resolve(__dirname, `../apiex/apiex-${lang}.yaml`),
    path.resolve(cwd, "apiex.yaml")
  );

  cpFile(
    path.resolve(__dirname, `../apiex/apiex-schema.gql`),
    path.resolve(cwd, "apiex-schema.gql")
  );

  cpFile(
    path.resolve(__dirname, `../apiex/template/apiex-${lang}.js`),
    path.resolve(cwd, `apiex-${lang}.js`)
  );

  console.log("apiex inited! Please run:");
  console.log("$ apiex");
  return;
}

const config = YAML.load(fs.readFileSync(path.resolve(cwd, yamlFile)));

async function Start() {
  let schemaCode = "";
  for (const p of config.graphql) {
    if (/http/.test(p)) {
      const code = await fetch(p).then((v) => v.text());
      schemaCode += code;
    } else {
      schemaCode += fs.readFileSync(path.resolve(cwd, p), "utf8");
    }
  }

  delete config.graphql;

  Object.keys(config).forEach((key) => {
    const conf = config[key];
    const {
      buildCombine,
      buildInterface,
      buildType,
      buildHandle,
      type,
    } = require(path.resolve(cwd, conf.builder));

    const schema = parser(schemaCode, type);

    const types = [];
    const interfaces = [];
    const handles = [];

    schema.forEach((item) => {
      if (item.kind == "interface") {
        if (buildInterface) {
          interfaces.push(
            buildInterface({
              ...item,
              firstUpperCase,
              capUpperCase,
            })
          );
        }
        if (buildHandle) {
          handles.push(
            buildHandle({
              ...item,
              firstUpperCase,
              capUpperCase,
            })
          );
        }
      } else {
        if (buildType) {
          types.push(
            buildType({
              ...item,
              firstUpperCase,
              capUpperCase,
            })
          );
        }
      }
    });

    let file = buildCombine({
      types: types.join("\n"),
      interfaces: interfaces.join("\n"),
      handles,
      schema: schemaCode,
    });

    const outPath = path.resolve(cwd, conf.out);
    const dir = path.parse(outPath).dir;
    if (!fs.existsSync(dir)) {
      fs.mkdirpSync(dir);
    }
    file = "// Code generated by linkgen. DO NOT EDIT." + file;
    fs.writeFileSync(outPath, file);
    console.log("Create done:", conf.out);
  });
}

Start();
